package Doxygen::XML;

use strict;
use warnings;
use namespace::autoclean;
use Moose;
use Moose::Util::TypeConstraints;
use File::Spec;

duck_type 'Doxygen::XML::Handler' => [qw(
	add_class
	set_stereotype
	add_operation
	add_attribute
	add_generalization
	add_aggregation
	add_composition
)];
has 'handler' => (is => 'rw', isa => 'Doxygen::XML::Handler', required => 1);

=head1 NAME

Doxygen::XML - parse the XML output format generated by Doxygen

=head1 SYNOPSIS

 use Doxygen::XML;
 use GraphViz::UML;
 my $doxml = Doxygen::XML->new({handler => GraphViz::UML->new});
 my @compounds = $doxml->parse_index($filename);
 $doxml->parse_compounds($_) for @compounds;

=head1 DESCRIPTION

Doxygen can output an XML representation of all the documented entities it
encounters in the source code it examines, by setting C<GENERATE_XML = YES> in
your C<Doxyfile>. Doxygen::XML will parse this representation and call methods
on a handler object for each class, member, and relation it discovers.

=head1 METHODS

=over

=item new

The constructor accepts a hashref of attributes.

=item parse_index($filename)

Parses an XML index file and returns a list of filenames of the compound XML
files that it references.

=item parse_compound($filename)

Parses an XML compound file. The return value is undefined.

=back

=head1 ATTRIBUTES

=over

=item handler

This is an object whose methods will be called for each class, member, and
relation discovered while parsing a file. It must provide the following
methods:

=over

=item add_class

=item set_stereotype

=item add_operation

=item add_attribute

=item add_generalization

=item add_aggregation

=item add_composition

=back

The L<GraphViz::UML> module is designed to provide these methods, but you
could also provide your own. See L<GraphViz::UML> for a discussion of the
parameters and semantics of these methods.

=back

=head1 AUTHORS

Available through the git repository at L<http://code.google.com/p/doxygraph>.

=head1 COPYRIGHT AND LICENSE

Copyright 2013 Doxygraph project

This Source Code Form is subject to the terms of the Mozilla Public License,
version 2.0. If a copy of the MPL was not distributed with this file, You can
obtain one at L<http://mozilla.org/MPL/2.0/>.

=head1 SEE ALSO

L<http://www.doxygen.org/>.

=cut

sub parse_index
{
  my ($self, $filename) = @_;
  
  my $root = Doxygen::XML::Index->new(file => $filename);
  
  my ($vol, $dir) = File::Spec->splitpath($filename);
  my @compounds;
  for (@{$root->compounds}) {
    if ($_->kind =~ m(^(class|struct|interface|protocol|exception)$)) {
      $self->handler->add_class($_->name, $_->refid);
      push @compounds, File::Spec->catpath($vol, $dir, $_->refid . '.xml');
    }
  }
  return @compounds;
}

sub parse_compound
{
  my ($self, $filename) = @_;
  
  my $root = Doxygen::XML::Compound->new(file => $filename);
  
  for (@{$root->compounddefs}) {
    if ($_->kind =~ m(^(class|struct|interface|protocol|exception)$)) {
      $self->_do_class($_);
    }
  }
}

sub _do_class
{
  my ($self, $compounddef) = @_;
  
  my $classname = $compounddef->name;
  
  my $stereotype;
  if ($compounddef->kind =~ m(interface|protocol|exception)) {
    $stereotype = $compounddef->kind;
  }
  if ($compounddef->abstract) {
    $stereotype = $stereotype ? "abstract $stereotype" : "abstract";
  }
  $self->handler->set_stereotype($classname, $stereotype) if $stereotype;
  
  for (@{$compounddef->basecompoundrefs}) {
    $self->handler->add_generalization($classname, $_->refid);
  }
  
  for (@{$compounddef->sectiondefs}) {
    for (@{$_->memberdefs}) {
      if ($_->kind =~ m(^(property|variable)$)) {
        $self->_do_attribute($classname, $_);
      } elsif ($_->kind =~ m(^(event|function|signal|prototype|friend|slot)$)) {
        $self->_do_operation($classname, $_);
      }
    }
  }
}

sub _do_attribute
{
  my ($self, $classname, $memberdef) = @_;
  
  my $attribute = {
    name => $memberdef->name,
    type => join('', @{$memberdef->type->text}),
    properties => [ _member_properties($memberdef) ]
  };
  $self->handler->add_attribute($classname, $attribute);
  
  for (@{$memberdef->type->refs}) {
    if ($attribute->{type} =~ m(([\*&]|_ptr|pointer))i) {
      $self->handler->add_aggregation($classname, $_->refid);
    } else {
      $self->handler->add_composition($classname, $_->refid);
    }
  }
}

sub _do_operation
{
  my ($self, $classname, $memberdef) = @_;
  
  my $operation = {
    name => $memberdef->name,
    type => join('', @{$memberdef->type->text}),
    properties => [ _member_properties($memberdef) ],
    parameters => [ _member_parameters($memberdef) ],
    paramstring => $memberdef->argsstring
  };
  $self->handler->add_operation($classname, $operation);
}

# Extract properties from a Doxygen::XML::Memberdef.
#
sub _member_properties
{
  my ($memberdef) = @_;
  
  my @properties;
  push @properties, grep { $memberdef->can($_)->($memberdef) eq 'yes' } qw(
    static const explicit inline volatile mutable readable writable initonly
    settable gettable final sealed add remove raise optional required);
  push @properties, map { $memberdef->can($_)->($memberdef) }
    grep { $memberdef->can($_)->($memberdef) } qw(prot virt accessor);
  push @properties, 'new' if $memberdef->new_;
  push @properties, 'derived' if @{$memberdef->reimplements};
  return @properties;
}

# Extract parameters as [name, type] tuples from a Doxygen::XML::Memberdef.
#
sub _member_parameters
{
  my ($memberdef) = @_;
  
  return map { [ $_->declname || '', join('', @{$_->type->text}) ] }
    @{$memberdef->params};
}

__PACKAGE__->meta->make_immutable;


package Doxygen::XML::Index; #################################################

use XML::Rabbit::Root;

has_xpath_value 'version' => '/doxygenindex/@version';

has_xpath_object_list 'compounds' => '/doxygenindex/compound'
	=> 'Doxygen::XML::Index::Compound';

finalize_class();


package Doxygen::XML::Index::Compound; #######################################

use XML::Rabbit;

has_xpath_value 'name' => './name';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'kind' => './@kind';

has_xpath_object_list 'members' => './member'
	=> 'Doxygen::XML::Index::Member';

finalize_class();


package Doxygen::XML::Index::Member; #########################################

use XML::Rabbit;

has_xpath_value 'name' => './name';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'kind' => './@kind';

finalize_class();


package Doxygen::XML::Compound; ##############################################

use XML::Rabbit::Root;

has_xpath_value 'version' => '/doxygen/@version';

has_xpath_object_list 'compounddefs' => '/doxygen/compounddef'
	=> 'Doxygen::XML::Compound::Compounddef';

finalize_class();


package Doxygen::XML::Compound::Compounddef; #################################

use XML::Rabbit;

has_xpath_value 'name' => './compoundname';
has_xpath_value 'id' => './@id';
has_xpath_value 'kind' => './@kind';
has_xpath_value 'prot' => './@prot';
has_xpath_value 'final' => './@final';
has_xpath_value 'sealed' => './@sealed';
has_xpath_value 'abstract' => './@abstract';
has_xpath_value 'title' => './title';

has_xpath_object 'location' => './location'
	=> 'Maybe[Doxygen::XML::Compound::Location]';

has_xpath_object_list 'memberrefs' => './listofallmembers/member'
	=> 'Doxygen::XML::Compound::Memberref';
has_xpath_object_list 'programlisting' => './programlisting/codeline'
	=> 'Doxygen::XML::Compound::Codeline';
has_xpath_object_list 'incdepgraph' => './incdepgraph/node'
	=> 'Doxygen::XML::Compound::Node';
has_xpath_object_list 'invincdepgraph' => './invincdepgraph/node'
	=> 'Doxygen::XML::Compound::Node';
has_xpath_object_list 'inheritancegraph' => './inheritancegraph/node'
	=> 'Doxygen::XML::Compound::Node';
has_xpath_object_list 'collaborationgraph' => './collaborationgraph/node'
	=> 'Doxygen::XML::Compound::Node';
has_xpath_object_list 'templateparams' => './templateparamlist/param'
	=> 'Doxygen::XML::Compound::Param';
has_xpath_object_list 'sectiondefs' => './sectiondef'
	=> 'Doxygen::XML::Compound::Sectiondef';
has_xpath_object_list 'basecompoundrefs' => './basecompoundref'
	=> 'Doxygen::XML::Compound::Compoundref';
has_xpath_object_list 'derivedcompoundrefs' => './derivedcompoundrefs'
	=> 'Doxygen::XML::Compound::Compoundref';
has_xpath_object_list 'includes' => './includes'
	=> 'Doxygen::XML::Compound::Inc';
has_xpath_object_list 'includedbys' => './includedby'
	=> 'Doxygen::XML::Compound::Inc';
has_xpath_object_list 'innerdirs' => './innerdir'
	=> 'Doxygen::XML::Compound::Ref';
has_xpath_object_list 'innerfiles' => './innerfile'
	=> 'Doxygen::XML::Compound::Ref';
has_xpath_object_list 'innerclasses' => './innerclass'
	=> 'Doxygen::XML::Compound::Ref';
has_xpath_object_list 'innernamespaces' => './innernamespace'
	=> 'Doxygen::XML::Compound::Ref';
has_xpath_object_list 'innerpages' => './innerpage'
	=> 'Doxygen::XML::Compound::Ref';
has_xpath_object_list 'innergroups' => './innergroup'
	=> 'Doxygen::XML::Compound::Ref';

finalize_class();


package Doxygen::XML::Compound::Memberref; ###################################

use XML::Rabbit;

has_xpath_value 'name' => './name';
has_xpath_value 'scope' => './scope';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'prot' => './@prot';
has_xpath_value 'virt' => './@virt';
has_xpath_value 'ambiguityscope' => './@ambiguityscope';

finalize_class();


package Doxygen::XML::Compound::Compoundref; #################################

use XML::Rabbit;

has_xpath_value 'value' => '.';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'prot' => './@prot';
has_xpath_value 'virt' => './@virt';

finalize_class();


package Doxygen::XML::Compound::Reimplement; #################################

use XML::Rabbit;

has_xpath_value 'value' => '.';
has_xpath_value 'refid' => './@refid';

finalize_class();


package Doxygen::XML::Compound::Inc; #########################################

use XML::Rabbit;

has_xpath_value 'value' => '.';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'local' => './@local';

finalize_class();


package Doxygen::XML::Compound::Ref; #########################################

use XML::Rabbit;

has_xpath_value 'value' => '.';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'prot' => './@prot';

finalize_class();


package Doxygen::XML::Compound::Reftext; #####################################

use XML::Rabbit;

has_xpath_value 'value' => '.';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'kindref' => './@kindref';
has_xpath_value 'external' => './@external';
has_xpath_value 'tooltip' => './@tooltip';

finalize_class();


package Doxygen::XML::Compound::Sectiondef; ##################################

use XML::Rabbit;

has_xpath_value 'kind' => './@kind';
has_xpath_value 'header' => './@header';

has_xpath_object_list 'memberdefs' => './memberdef'
	=> 'Doxygen::XML::Compound::Memberdef';

finalize_class();


package Doxygen::XML::Compound::Memberdef; ###################################

use XML::Rabbit;

has_xpath_value 'name' => './name';
has_xpath_value 'kind' => './@kind';
has_xpath_value 'id' => './@id';
has_xpath_value 'definition' => './definition';
has_xpath_value 'argsstring' => './argsstring';
has_xpath_value 'read' => './read';
has_xpath_value 'write' => './write';
has_xpath_value 'bitfield' => './bitfield';
has_xpath_value 'prot' => './@prot';
has_xpath_value 'static' => './@static';
has_xpath_value 'const' => './@const';
has_xpath_value 'explicit' => './@explicit';
has_xpath_value 'inline' => './@inline';
has_xpath_value 'virt' => './@virt';
has_xpath_value 'volatile' => './@volatile';
has_xpath_value 'mutable' => './@mutable';
has_xpath_value 'readable' => './@readable';	# Qt
has_xpath_value 'writable' => './@writable';	# Qt
has_xpath_value 'initonly' => './@initonly';	# C++/CLI and C#
has_xpath_value 'settable' => './@settable';	# C++/CLI
has_xpath_value 'gettable' => './@gettable';	# C++/CLI
has_xpath_value 'final' => './@final';		# C++/CLI
has_xpath_value 'sealed' => './@sealed';	# C++/CLI
has_xpath_value 'new_' => './@new';		# C++/CLI
has_xpath_value 'add' => './@add';		# C++/CLI
has_xpath_value 'remove' => './@remove';	# C++/CLI
has_xpath_value 'raise' => './@raise';		# C++/CLI
has_xpath_value 'optional' => './@optional';	# ObjC
has_xpath_value 'required' => './@required';	# ObjC
has_xpath_value 'accessor' => './@accessor';	# ObjC

has_xpath_object 'type' => './type'
	=> 'Doxygen::XML::Compound::Linkedtext';
has_xpath_object 'initializer' => './initializer'
	=> 'Doxygen::XML::Compound::Linkedtext';
has_xpath_object 'exceptions' => './exceptions'
	=> 'Doxygen::XML::Compound::Linkedtext';
has_xpath_object 'location' => './location'
	=> 'Doxygen::XML::Compound::Location';

has_xpath_object_list 'templateparams' => './templateparamlist/param'
	=> 'Doxygen::XML::Compound::Param';
has_xpath_object_list 'reimplements' => './reimplements'
	=> 'Doxygen::XML::Compound::Reimplement';
has_xpath_object_list 'reimplementedbys' => './reimplementedby'
	=> 'Doxygen::XML::Compound::Reimplement';
has_xpath_object_list 'params' => './param'
	=> 'Doxygen::XML::Compound::Param';
has_xpath_object_list 'enumvalues' => './enumvalue'
	=> 'Str|Doxygen::XML::Compound::Enumvalue';
has_xpath_object_list 'references' => './references'
	=> 'Doxygen::XML::Compound::Reference';
has_xpath_object_list 'referencedbys' => './referencedby'
	=> 'Doxygen::XML::Compound::Reference';

finalize_class();


package Doxygen::XML::Compound::Enumvalue; ###################################

use XML::Rabbit;

has_xpath_value 'name' => './name';
has_xpath_value 'id' => './@id';
has_xpath_value 'prot' => './@prot';

has_xpath_object 'initializer' => './initializer'
	=> 'Doxygen::XML::Compound::Linkedtext';

finalize_class();


package Doxygen::XML::Compound::Param; #######################################

use XML::Rabbit;

has_xpath_value 'declname' => './declname';
has_xpath_value 'defname' => './defname';
has_xpath_value 'array' => './array';

has_xpath_object 'type' => './type'
	=> 'Doxygen::XML::Compound::Linkedtext';
has_xpath_object 'defval' => './defval'
	=> 'Doxygen::XML::Compound::Linkedtext';

finalize_class();


package Doxygen::XML::Compound::Linkedtext; ##################################

use XML::Rabbit;

has_xpath_value_list 'text' => './text()|./ref';

has_xpath_object_list 'refs' => './ref'
	=> 'Doxygen::XML::Compound::Reftext';

finalize_class();


package Doxygen::XML::Compound::Node; ########################################

use XML::Rabbit;

has_xpath_value 'label' => './label';
has_xpath_value 'id' => './@id';

has_xpath_object 'link' => './link'
	=> 'Maybe[Doxygen::XML::Compound::Link]';

has_xpath_object_list 'childnodes' => './childnode'
	=> 'Doxygen::XML::Compound::Childnode';

finalize_class();


package Doxygen::XML::Compound::Childnode; ###################################

use XML::Rabbit;

has_xpath_value 'refid' => './@refid';
has_xpath_value 'relation' => './@relation';

has_xpath_value_list 'edgelabels' => './edgelabel';

finalize_class();


package Doxygen::XML::Compound::Link; ########################################

use XML::Rabbit;

has_xpath_value 'refid' => './@refid';
has_xpath_value 'external' => './@external';

finalize_class();


package Doxygen::XML::Compound::Codeline; ####################################

use XML::Rabbit;

has_xpath_value 'lineno' => './@lineno';
has_xpath_value 'refid' => './@refid';
has_xpath_value 'refkind' => './@refkind';
has_xpath_value 'external' => './@external';

finalize_class();


package Doxygen::XML::Compound::Reference; ###################################

use XML::Rabbit;

has_xpath_value 'refid' => './@refid';
has_xpath_value 'compoundref' => './@compoundref';
has_xpath_value 'startline' => './@startline';
has_xpath_value 'endline' => './@endline';

finalize_class();


package Doxygen::XML::Compound::Location; ####################################

use XML::Rabbit;

has_xpath_value 'file' => './@file';
has_xpath_value 'line' => './@line';
has_xpath_value 'bodyfile' => './@bodyfile';
has_xpath_value 'bodystart' => './@bodystart';
has_xpath_value 'bodyend' => './@bodyend';

finalize_class();

1;
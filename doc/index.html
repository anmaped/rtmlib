<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rtmlib: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rtmlib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">rtmlib Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview </h1>
<p>The RunTime embedded Monitoring Library (rtmlib) has been initially developed for runtime monitoring of real-time embedded systems either for ARM and X86 platforms. rtmlib is a lean library that supports atomic operations on shared memory circular buffers and implements a monitor abstraction layer for infinite sequences of time-stamped symbols or events. This library is used to implement different monitoring architectures such as the ones proposed in [1] and [2]. Other efficient architectures can be deployed based on lock-free push, pull, pop primitives over inifnite trace sequences containing time-stamped events. The synchronization primitives for push, pull and pop operations allow different readers and writers to progress asynchronously over the instantiated circular buffers and to synchronize when required. Indeed, the rtmlib solves the lock-free producer-consumer problem for circular buffer-based FIFO queues where readers are consumers and writers are producers.</p>
<p>The rtmlibv0.2 is not just an improved version of rtmlibv0.1 but is also a library that supports hardware synthesis via Vivado HLS tool. The rtmlib can support software and hardware monitoring via dedicated CPU and FPGA devices. The figure Hybrid Overview show our new approach.</p>
<div class="image">
<img src="hybrid_overview.png" alt="hybrid_overview.png"/>
</div>
<p>rtmlib has a direct connection with the rmtld3synth tool as a monitor integration layer. rmtld3synth is a tool that can generate cpp11 monitors and can be implemented in software or hardware.</p>
<h1><a class="anchor" id="usagertml"></a>
Usage of RTMLib </h1>
<h2><a class="anchor" id="istantiating"></a>
Interface header and buffer </h2>
<p>A buffer is a continuous memory array that is shared between the monitor and the system under observation (SUO). The buffer includes sequences with time-stamped symbols or events that identify changes in the SUO state. RTMLib requires at least one global buffer available for system instrumentation, and the link step must provide the buffer address to external monitors. For that, we use a "interface.h" header file as the interface definition to be used by both tasks, SUO and monitor. Note that, by default, a monitor runs on a task. __start_periodic_monitors function is able to start all monitors. Note also that symbols are integers from 0 to 255 by default (uint8_t ). Other types such as uint16_t and uint32_t are also available. Strings and classes should be avoided. We encourage the programmers to statically map these events using a hash table to reduce memory footprint.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef INTERFACE_H</span></div><div class="line"><span class="preprocessor">#define INTERFACE_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="circularbuffer_8h.html">circularbuffer.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> __start_periodic_monitors();</div><div class="line"></div><div class="line"><span class="comment">// defines a buffer with 100 elements and each element of type uint8_t</span></div><div class="line"><span class="keyword">extern</span> <a class="code" href="classRTML__buffer.html">RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt; __buffer;</div><div class="line"></div><div class="line"><span class="comment">// symbols that mean events or propositions</span></div><div class="line"><span class="preprocessor">#define EV_C 3</span></div><div class="line"><span class="preprocessor">#define EV_A 2</span></div><div class="line"><span class="preprocessor">#define EV_B 1</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif // INTERFACE_H</span></div></div><!-- fragment --><p>The instantiation of the buffers and initialization of the monitors should be similar to the next block of code. Note that it is not necessary to instantiate the buffer with the monitors. The buffer is a memory position that must be accessible by the monitor and SUO. Whoever initializes the buffer is left to the programmer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;interface.h&quot;</span>     <span class="comment">// the interface to use with SUO</span></div><div class="line"><span class="preprocessor">#include &quot;simplemonitor.h&quot;</span> <span class="comment">// includes the monitor 1 as M_simple class</span></div><div class="line"></div><div class="line"><span class="comment">// constructs a global __buffer buffer</span></div><div class="line"><a class="code" href="classRTML__buffer.html">RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt; __buffer;</div><div class="line"></div><div class="line"><span class="comment">// construct two simple monitors</span></div><div class="line">M_simple simplem1(5000000);  <span class="comment">// 5 seconds period</span></div><div class="line">M_simple simplem2(10000000); <span class="comment">// 10 seconds period</span></div><div class="line"></div><div class="line"><span class="comment">// enables the monitor initialization</span></div><div class="line"><span class="keywordtype">void</span> __start_periodic_monitors() {</div><div class="line">  <span class="keywordflow">if</span> (simplem1.enable()) {</div><div class="line">    ::printf(<span class="stringliteral">&quot;ERROR\n&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (simplem2.enable()) {</div><div class="line">    ::printf(<span class="stringliteral">&quot;ERROR\n&quot;</span>);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> <code>M_simple.h</code> header defines a monitor according to the section 'Develop a simple monitor' as defined below. <code>M_morecomplex.h</code> header defines another monitor that shares the buffer <code>__buffer_monitor_set1</code>. <code>__start_periodic_monitors</code> is a procedure to trigger the initialization of the monitors.</p>
<h2><a class="anchor" id="smonitor"></a>
Develop a simple Monitor </h2>
<p>Let us build a simple monitor on top of the <a class="el" href="classRTML__monitor.html">RTML_monitor</a> class. The <a class="el" href="classRTML__monitor.html">RTML_monitor</a> class enables programmers to run monitors over a given period of time, and is started using some arguments such as period, scheduler policy, and priority. The policies and priorities of the scheduler are OS dependent. For instance, we only have the SCHED_FIFO policy available in pthreads-win32, and priorities can be negative ranging from -15(lowest) to 15(highest). Zero is the normal priority. For fully Posix compliant OS, priorities are not negative and there are some other policies such as SCHED_RRR (round robin) and SCHED_OTHER. Since NuttX OS is a Posix compliant OS, we have the same policies. The next block of code displays the string <em>Body of the monitor.</em> several times with a period of <code>p</code> useconds.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;interface.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="periodicmonitor_8h.html">periodicmonitor.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;reader.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>M_simple : <span class="keyword">public</span> <a class="code" href="classRTML__monitor.html">RTML_monitor</a> {</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classRTML__reader.html">RTML_reader&lt;RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt;&gt; __reader =</div><div class="line">      <a class="code" href="classRTML__reader.html">RTML_reader&lt;RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt;&gt;(__buffer);</div><div class="line"></div><div class="line">  uint8_t gap;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classRTML__monitor.html#a5714bf86785904cda878fca20f010b79">run</a>() {</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> count = 0;</div><div class="line">    ::printf(<span class="stringliteral">&quot;run simplemonitor job #%d begin...\n&quot;</span>, count);</div><div class="line"></div><div class="line">    ::printf(<span class="stringliteral">&quot;run simplemonitor job #%d end.\n&quot;</span>, count);</div><div class="line">    count++;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  M_simple(useconds_t p)</div><div class="line">      : <a class="code" href="classRTML__monitor.html">RTML_monitor</a>(p, SCHED_OTHER, 0), gap(0) {</div><div class="line">  } <span class="comment">// use SCHED_FIFO for real-time</span></div><div class="line">};</div></div><!-- fragment --><p>Let us now overwrite the <code>run</code> procedure with a consumer procedure as exemplified in section 'Consumer procedure'.</p>
<h3><a class="anchor" id="consumerp"></a>
Consumer procedure</h3>
<p>The consumer process is exemplified using one lambda function that returns a pointer of type <code>void *</code> and receives an argument of type <code>void *</code>. It fits the required interface defined in <a class="el" href="classRTML__monitor.html">RTML_monitor</a> for the procedure <code>run</code>. The body of the function initializes an object of type <code><a class="el" href="classRTML__reader.html">RTML_reader</a>&lt;int&gt;</code> that will be used as the consumer for the lock-free buffer. The procedure <code>dequeue()</code> peek a tuple containing an event of type <code><a class="el" href="classEvent.html">Event</a>&lt;int&gt;</code>, where the template typename is the type of the expected identifier of the event, and a time-stamp. Note that the dequeue is local to the reader, does not affect the global buffer, and can be synchronized using a certain time-stamp. However, to get a global dequeue of a certain event, we shall share the same reader among the tasks.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> run() {</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> count = 0;</div><div class="line">  ::printf(<span class="stringliteral">&quot;run simplemonitor job #%d begin...\n&quot;</span>, count);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> consumer = [&amp;](<span class="keywordtype">void</span> *) -&gt; <span class="keywordtype">void</span> * {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (__reader.synchronize())</div><div class="line">      gap++;</div><div class="line"></div><div class="line">    assert(gap &lt;= 1); <span class="comment">// ensure that we have no gaps</span></div><div class="line"></div><div class="line">    <a class="code" href="classEvent.html">Event&lt;uint8_t&gt;</a> tmpEvent;</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="task__compat_8h.html#a015eb90e0de9f16e87bd149d4b9ce959">status</a> = __reader.pull(tmpEvent);</div><div class="line"></div><div class="line">    ::printf(<span class="stringliteral">&quot;consumed event: %lu, %d status: %d\n&quot;</span>, tmpEvent.<a class="code" href="classEvent.html#aacd8000760c0f73852f5d745d5060bc4">getTime</a>(),</div><div class="line">             tmpEvent.<a class="code" href="classEvent.html#a2aea9d0e03ec0ab55ce205798546d9e1">getData</a>(), <a class="code" href="task__compat_8h.html#a015eb90e0de9f16e87bd149d4b9ce959">status</a>);</div><div class="line"></div><div class="line">    __reader.<a class="code" href="classEvent.html#a5a8e3b665f8009acbf482ac55be7da14">debug</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> NULL;</div><div class="line">  };</div><div class="line"></div><div class="line">  consumer(NULL);</div><div class="line"></div><div class="line">  ::printf(<span class="stringliteral">&quot;run simplemonitor job #%d end.\n&quot;</span>, count);</div><div class="line">  count++;</div><div class="line">}</div></div><!-- fragment --><p>The variable <code>tmpEvent</code> stores the dequeued event, where the methods <code>getTime()</code> and <code>getData()</code> return the time-stamp and the event identifier, respectively.</p>
<h2><a class="anchor" id="producerp"></a>
Develop a simple instrumentation (Producer procedure)</h2>
<p>Let us build a procedure for the production of time-stamped symbols on circular buffers. First, we initialize the <code>__writer</code> object of the type <code><a class="el" href="classRTML__writer.html">RTML_writer</a>&lt;int&gt;</code>. Next, we push a symbol of the type <code>int</code> with a timestamp to the buffer that accepts events of the type <code><a class="el" href="classEvent.html">Event</a>&lt;int&gt;</code>, and finally we print the buffer with the <code>debug</code> helper function to the stdout for debugging purposes.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> producer = [](<span class="keywordtype">void</span> *) -&gt; <span class="keywordtype">void</span> * {</div><div class="line">  <span class="keyword">static</span> <a class="code" href="classRTML__writer.html">RTML_writer&lt;RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt;&gt; __writer =</div><div class="line">      <a class="code" href="classRTML__writer.html">RTML_writer&lt;RTML_buffer&lt;Event&lt;uint8_t&gt;</a>, 100&gt;&gt;(__buffer);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> count = 0;</div><div class="line">  ::printf(<span class="stringliteral">&quot;run suo job #%d begin...\n&quot;</span>, count);</div><div class="line"></div><div class="line">  <a class="code" href="classEvent.html">Event&lt;uint8_t&gt;</a> id(EV_A, 0); <span class="comment">// set event to id EV_A</span></div><div class="line">  __writer.<a class="code" href="classRTML__writer.html#af1173d1f78a0a38ecc4cc64560edcd8c">push</a>(<span class="keywordtype">id</span>);       <span class="comment">// writer will time-stamp the event</span></div><div class="line"></div><div class="line">  __buffer.<a class="code" href="classRTML__buffer.html#a4e89362783cbbdac6ff4973295d7df42">debug</a>();</div><div class="line"></div><div class="line">  ::printf(<span class="stringliteral">&quot;run suo job #%d end.\n&quot;</span>, count);</div><div class="line">  count++;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="structtask.html">__task</a> producer_A = <a class="code" href="task__compat_8h.html#a77d369d51da0f71b0d50be2ea67cab4a">__task</a>(<span class="stringliteral">&quot;producer&quot;</span>, producer, 0, SCHED_OTHER, 2000000); <span class="comment">// use SCHED_FIFO for real-time</span></div></div><!-- fragment --><p>Note that <code>__task</code> is also an helper function that we use to construct the data descriptor of a task. It is composed by a function pointer, a priority, a scheduler policy, and a period. <code>100000</code> means 1/10 seconds.</p>
<h2>Implementation details</h2>
<p>Use the example folder to see some simple instrumentation and monitor construction examples.</p>
<p>See <a class="el" href="md_doc_task_helpers.html">task helpers</a> for more details.</p>
<p>See <a class="el" href="md_doc_lock_free.html">lock-free circular buffer</a> for more details.</p>
<p>See <a class="el" href="md_doc_other.html">the class diagram</a> for more information.</p>
<h2>References</h2>
<p>[1] de Matos Pedro A., Pereira D., Pinho L.M., Pinto J.S. (2014) Towards a Runtime Verification Framework for the Ada Programming Language. In: George L., Vardanega T. (eds) Reliable Software Technologies – Ada-Europe 2014. Ada-Europe 2014. Lecture Notes in Computer Science, vol 8454. Springer, Cham. <a href="https://doi.org/10.1007/978-3-319-08311-7_6">https://doi.org/10.1007/978-3-319-08311-7_6</a></p>
<p>[2] Nelissen G., Pereira D., Pinho L.M. (2015) A Novel Run-Time Monitoring Architecture for Safe and Efficient Inline Monitoring. In: de la Puente J., Vardanega T. (eds) Reliable Software Technologies – Ada-Europe 2015. Ada-Europe 2015. Lecture Notes in Computer Science, vol 9111. Springer, Cham. <a href="https://doi.org/10.1007/978-3-319-19584-1_5">https://doi.org/10.1007/978-3-319-19584-1_5</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
